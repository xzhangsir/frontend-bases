<!DOCTYPE html>
<!-- <!DOCTYPE html> 删除这个浏览器的渲染 模式会变成怪异模式 向后兼容-->
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>DOM初探</title>
	<style type="text/css">
		*{
			margin:0;
			padding:0;
		}
		/*选项卡功能
		.content{
			display:none;
			width:200px;
			height:200px;
			border:2px solid #f40;
		}
		.act{
			background-color:yellow;
		}*/
	</style>
</head>
<body>
	<!-- 第一天认识DOM -->

	<!--点击方块变色
	 <div></div>
	<script type="text/javascript">
		var div = document.getElementsByTagName('div')[0];
		div.style.width = "100px";
		div.style.height = "100px";
		div.style.backgroundColor = "red";
		var num = 0 ;
		div.onclick = function(){
			num++;
			if(num % 2 == 1){
				div.style.backgroundColor = "green";
			}else{
				div.style.backgroundColor = "red";
			}
		}
	</script> -->


 	<!-- 选项卡功能
 	<div class = "wrapper">
		<button class = "act">one</button>
		<button>two</button>
		<button>three</button>
		<div class = "content" style = "display :block" >111</div>
		<div class = "content">222</div>
		<div class = "content">333</div>
	</div>
	<script type="text/javascript">
		var but = document.getElementsByTagName('button');
		var con = document.getElementsByClassName('content');
		for(var i = 0 ; i < but.length ; i++){
			(function(i){
				but[i].onclick = function(){
					for(var j = 0 ; j < con.length ; j++){
						but[j].className = "";
						con[j].style.display = 'none'; 
					}
					this.className = "act";
					con[i].style.display = 'block'; 
				}
			}(i))
		}	
	</script> -->
	<!--小方块的移动
	 <script type="text/javascript">
		var div = document.createElement('div');//在页面中创建一个div
		document.body.appendChild(div);//将创建的div添加到页面中去
		div.style.width = "100px";
		div.style.height = "100px";
		div.style.backgroundColor = "red";
		div.style.position = "absolute";
		div.style.left = "0";
		div.style.top = "0";
		// setInterval(function(){
		// 	div.style.left = parseInt(div.style.left) + 2 + "px";
		// 	div.style.top = parseInt(div.style.top) + 2 +"px";
		// },300)
		
		document.onkeydown = function(e){
			switch(e.which){
				case 37:
				div.style.left = parseInt(div.style.left) - 2 + "px";
				break;
				case 39:
				div.style.left = parseInt(div.style.left) + 2 + "px";
				break;
				case 38:
				div.style.top = parseInt(div.style.top) - 2 + "px";
				break;
				case 40:
				div.style.top = parseInt(div.style.top) + 2 + "px";
				break;
			}
		}
	</script> -->
	



	<!-- 节点的查找 -->
	<!-- <div id="only"></div> -->
	<!-- <div class = "lei">
		<div>
			<span class="span">123</span>
		</div>
		<div>789</div>
		<span>
			<p>456</p>
		</span>
		<em>
			<p>
				<del></del>
			</p>
		</em>
	</div> -->
	<!-- <div name = "ming"></div> -->
	<!-- <script>
		//var div = document.getElementById('only');
		//通过ID查找元素i
		//在Ie8以下的浏览器，不区分id大小写，而且也返回匹配name属性的元素
		//var div = document.getElementsByTagName('div')[0];
		//通过标签名查找元素  拿出来的是一个类数组 兼容性很好
		//var div = document.getElementsByClassName('lei')[0];
		//通过class查找元素  ie8和ie8以下的ie中没有，可以多个class一起
		//var div = document.getElementsByName('ming')[0];
		//理论上只有部分标签name可生效（表单，表单元素，img，iframe）
		
		//var span = document.querySelector('.lei div .span');
		//在ie7和ie7以下的版本中没有 可以按照css的选择方法去选择元素
		//var span = document.querySelectorAll('.lei div .span')[0];
		//同上  选择的是一组  但是他和上面的选择的都不是实时的


		//var div = document.getElementsByTagName('div')[0];
		// 遍历节点树（文本节点 注释节点 元素节点等）
		// var father = div.parentNode;//找父节点
		// var child  = div.childNodes;//找子节点们
		// var first = div.firstChild;//找第一个子节点
		// var last = div.lastChild;//找最后一个子节点
		// var hou  = div.nextSibling;//找后一个兄弟元素
		// var qian = div.previousSibling;//找前一个兄弟元素
		//div.cloneNode()//克隆div节点   1：如果传true 就包含子集 2：不传参  则不包含
		
		//遍历元素节点树(看好是元素)
		//var father = div.parentElement;
		//返回当前元素的父元素节点 (IE9以下不兼容)
		//var child = div.children;//只返回当前元素的元素子节点们
		//var first = div.firstElementChild;
		//返回第一个子元素节点(IE9以下不兼容)
		//var last = div.lastElementChild;
		//返回最后一个子元素节点(IE9以下不兼容)
		//var hou = div.nextElementSibling;
		//返回后一个兄弟元素节点(IE9以下不兼容)
		//var qian = div.previousElementSibling;
		//返回前一个兄弟元素节点(IE9以下不兼容)
		//var name  = div.children[1].nodeName;
		//返回的是元素的标签名 字符串 以大写形式表示,只读
		//var value  = div.childNodes[3].nodeValue;
		//Text节点或Comment(注释)节点的文本内容,可读写
		//var type  = div.children[1].nodeType;
		//该节点的类型，只读 元素节点 1 属性节点 2 文本节点 3 
		//注释节点 8 document 9 DocumentFragment 11
		//var shuxing = div.attributes;
		//该元素节点的属性集合
		//var zi = div.hasChildNodes();
		//检查元素是否有子节点 返回 true/false
		

		// 封装一个函数返回元素e的第n层祖先元素节点
		// var del = document.getElementsByTagName('del')[0];
		// function reparent(elem,n){
		// 	while(elem & n){
		// 		elem = elem.parentelement;
		// 		n--;
		// 	}
		// 	return elem;
		// }


		// 封装children函数
		// var div = document.getElementsByTagName('div')[0];
		// Element.prototype.mychildren = function(){
		// 	var arr = [],
		// 		child = this.childNodes,
		// 		len = child.length;
		// 	for(var i = 0 ; i < len ; i++){
		// 		if(child[i].nodeType == 1){
		// 			arr.push(child[i]);
		// 		}
		// 	}
		// 	return arr;
		// }
	</script> -->
	

	<!-- 节点的增加 -->
	<!-- <script>
		var div = document.createElement('div');//创建一个div
		document.body.appendChild(div);//将创建的div添加到页面中
		var text = document.createTextNode('创建文本节点');
		var comment = document.createComment('创建注释节点');		
	</script> -->

	<!-- 节点的插入 -->
	<!-- <div>
			<span></span>
		</div>
	<script>
		var div = document.getElementsByTagName('div')[0];
		var text = document.createTextNode('创建的文本节点');
		div.appendChild(text);

		var span = document.getElementsByTagName('span')[0];
		var stroninsertBeforeg = document.createElement('strong');
		div.insertBefore(strong,span);
		//在div中将strong插入到span前 一定是父级调用
	</script> -->


 	<!-- 节点的删除 -->
	<!-- <div>
			<span></span>
		</div>
	<script>
		var div = document.getElementsByTagName('div')[0];
		var span = document.getElementsByTagName('span')[0];
		div.removeChild(span);//实际上span标签是被剪贴出去了
		div.remove();//直接自尽
	</script> -->
	
	<!-- 节点的替换 -->
	<!-- <div>
		<span></span>
	</div>
	<script>
		var div = document.getElementsByTagName('div')[0];
		var span = document.getElementsByTagName('span')[0];
		var p = document.createElement('p');
		div.replaceChild(p,span);//用p标签去替换span标签
	</script> -->

	<!-- 元素节点的属性 -->
	<!-- <div>
		<span>123</span>
	</div>
	<script>
		var div = document.getElementsByTagName('div')[0];
		//console.log(div.innerHTML);//取出节点中的内容（节点和文本）
		//div.innerHTML = '1230';//向div节点中写入数据 会覆盖原有的数据
		//div.innerHTML += '456';//在原来的基础上添加
		//div.innerHTML = "<p>456</p>";//可以直接写HTML代码
		console.log(div.innerText);//取出div里面的文本 老版本火狐不兼容 火狐提供了textContent但是老版本IE没有
	</script> -->
	
	<!-- 元素节点的一些方法 -->
	<!-- <div class = "i"></div>
	<script>
		//var div = document.getElementsByTagName('div')[0];
		//div.setAttribute('class','demo');//在标签上添加或改变属性
		//console.log(div.getAttribute('class'));//取出这个属性
		//div.className = "change";//可以修改这个标签的class值
	</script> -->

	<!-- class操作 -->
	<!-- <script>
		div.classList.add('class名')
		div.classList.remove('class名')
		div.classList.toggle('class名')
		div.classList.contains('class名')
	</script> -->
	
	<!-- 日期对象 -->
	<!-- minutes:<input type="text" value="0"style = "text-align: right;">
	seconds:<input type="text" value="0"style = "text-align: right;"> -->
	<!-- <script>
		var date = new Date();
		//console.log(date.getTime());//返回1970年1月1日到当前的毫秒数
		//console.log(date.toString());//将Date对象转换成字符串
		
		// 定时器  时间不准确
		// var timer = setInterval(function(){
		// 	console.log(0);
		// },100)//每100毫秒执行一次function中的方法
		// clearInterval(timer);//停止上面的定时器
		// 特殊的写法
		// setInterval('console.log(1)',10);
		  
		//定时炸弹	时间不准确
		// var timer = setTimeout(function(){
		// 	console.log(0);
		// },1000)//1000毫秒后很执行 只执行一次
		// clearTimeout(timer);//停止定时器
		var minutes = document.getElementsByTagName("input")[0];
		var seconds = document.getElementsByTagName("input")[1];
		var timer = setInterval(function(){
			seconds.value++;
			if(seconds.value == 1000){
				seconds.value = 0;
				minutes.value++;
			} 
			if(minutes.value == 3){
				clearInterval(timer);
			}
		},1)
	</script> -->

	<!-- 滚动条 -->
	<!-- <script>
		window.pageXOffset;//滚边条滚动的X轴距离IE8及IE8以下不兼容
		window.pageYOffset;//滚边条滚动的Y轴距离IE8及IE8以下不兼容
		document.body.scrollLeft;
		doucment.documentElement.scrollLeft;
		//IE9一下用上面这两个求滚动的X轴距离 具体用哪个不好说 兼容性很乱
		doucment.body.scrollTop;
		doucment.documentElement.scrollTop;
		//IE9一下用上面这两个求滚动的Y轴距离 具体用哪个不好说 兼容性很乱
		document.body.scrollLeft + doucment.documentElement.scrollLeft;//可以将这两个相加解决IE9一下的兼容问题

		//封装方法解决所有浏览器上是滚动条兼容的问题
		function getScrollOffset(){
			if(window.pageXOffset){
				return{
					X:window.pageXOffset,
					Y:window.pageYOffset
				}
			}else{
				return{
					X:document.body.scrollLeft + doucment.documentElement.scrollLeft,
					Y:document.body.scrollTop + doucment.documentElement.scrollTop
				}
			}
		} 
	</script> -->

	<!-- 可视区窗口的尺寸 -->
	<!-- <script>
		window.innerWidth;//窗口的宽度 IE8及IE8以下不兼容
		window.innerHeight;//窗口的高度  IE8及IE8以下不兼容
		document.documentElement.clientWidth;
		//IE9一下的浏览器在标准模式下 获得窗口的宽
		document.documentElement.clientHeight;
		//IE9一下的浏览器在标准模式下 获得窗口的高
		document.body.clientWidth;
		//IE9一下的浏览器在怪异模式下 获得窗口的宽
		document.body.clienHeight;
		//IE9一下的浏览器在怪异模式下 获得窗口的高
		document.compatMode;
		//判断浏览器处于怪异模式和是标准模式 标准模式返回 CSS1compat
		//								  怪异模式返回 BackCompat
		
		//封装兼容性方法，返回浏览器视口尺寸
		function getViewportOffset(){
			if(window.innerWidth){
				return{
					W : window.innerWidth,
					H : window.innerHeight
				}
			}else{
				if(document.compatMode == 'CSS1compat'){
					return {
						W : document.documentElement.clientWidth,
						H : document.documentElement.clientHeight
					}
				}else{
					return {
						W : document.body.clientWidth,
						H : document.body.clientHeight
					}
				}
			}
		}
	</script>
 -->
	
	<!-- 元素的几何尺寸 -->
	<!-- <div style = "width:100px ; height:100px; background-color:red;position:absolute; left:100px;top:100px"></div>
	<script>
		var div = document.getElementsByTagName('div')[0];
		//div.getBoundingClientRect();
		//该方法返回一个对象，对象里面有left,top,right,bottom,width,height等属性。left和top代表该元素左上角的X和Y坐标，right和bottom代表元素右下角的X和Y坐标   但是 width 和 height在老版本IE中没有 返回的结果不是实时的
		
		div.offsetWidth;//查看元素的宽 padding+width
		div.offsetHeight;//查看元素的高 padding+height
		div.offsetLeft;//查看元素的位置 对于无定位父级的元素，返回相对文档的坐标。对于有定位父级的元素，返回相对于最近的有定位的父级的坐标
		div.offsetTop;//同上
		dom.offsetParent;//返回最近的有定位的父级 如无返回null	
	</script> -->
	
	<!-- 让滚动条滚动 -->
	<!-- <script>
		//window.scroll(10,10);
		//window.scrollTo(10,10);
		//上面这两个方法一样 让滚动条在X和Y轴上滚动10px 不会在原来的基础上累加
		//window.scrollBy(10,10);
		//让滚动条在X和Y轴上滚动10px,会在原来的基础上累加
	</script> -->
	
	<!-- 自动阅读 -->
	<!-- <div style = "width:100px; height:100px;background-color: rgba(250,0,0,0.5);position: fixed;left:10px;bottom: 300px;font-size: 35px;line-height: 100px ; text-align: center;border-radius: 50%;color:#fff">开始</div>
	<div style = "width:100px; height:100px;background-color: rgba(0,250,0,0.5);position: fixed;left:10px;bottom: 190px;font-size: 35px;line-height: 100px ; text-align: center;border-radius: 50%;color:#fff">暂停</div>
	<script>
		var div1 = document.getElementsByTagName('div')[0];
		var div2 = document.getElementsByTagName('div')[1];
		var timer = 0;
		var key = true;
		div1.onclick = function(){
			if(key){
				timer = setInterval(function(){
				window.scrollBy(0,1);
				},10)
			}
			 key = false;
		}
		div2.onclick = function(){
			clearInterval(timer);
			key = true;
		}
	</script> -->

	<!-- 脚本化CSS 只能读取(没有返回"")或者设置行间样式切记是行间样式-->
	<!-- <div style = "width :200px; height : 200px ; background-color:red;float:left"></div>
	<div style = "width :200px; height : 200px ; background-color:green; float:left" ></div>
	<script>
		var div = document.getElementsByTagName('div')[0];
		//div.style.width = "300px";//可读可写
		//div.style.backgroundColor = "#00f";//可读可写 兼容性很好
		//碰到float这样的关键字属性，前面应加css //eg:div.style.cssFloat;
		//window.getComputedStyle(div,null).width;
		//上面这个获取的是这个元素属性可视的值(看到是多少就是多少) 不可写
		//IE8及IE8以下不兼容 获取的是绝对值
		//div.currentStyle.width;//IE9以下用这个获取 IE独有

		// 封装兼容性方法getStyle
		// function getStyle(elem,prop){
		// 	if(window.getComputedStyle){
		// 		return window.getComputedStyle(elem,null)[prop];
		// 	}else{
		// 		return elem.currentStyle[prop];
		// 	}
		// }

		//获取伪元素的样式  如下：
		//window.getComputedStyle(div,"after").width;
	</script> -->

	<!-- 事件 -->
	<!-- <div style="width:100px;height:100px;background-color:red"></div>

	<script>
		var div = document.getElementsByTagName('div')[0];
		//绑定事件第一种方法 但是一个元素只能绑定一个处理程序 兼容性很好
		// div.onclick = function(){//句柄式
		// 	this.style.backgroundColor = "green";
		// 	console.log(this);//这个this指向dom对象本身
		// }
		// 上面的方法等同于 下面这样
		// <div style="width:100px;height:100px;background-color:red" onclick = "console.log('a')"></div>
		// 
		// 解除上面的事件  div.onclick = null;
		
		//绑定事件第二种方法 可以为一个事件绑定多个处理程序 IE9一下不兼容
		//div.addEventListener('事件类型'，处理函数，false);
		// div.addEventListener('click',function(){
		// 	console.log('a');
		// 	console.log(this);//这个this指向dom对象本身
		// },false)
		// div.addEventListener('click',function(){
		// 	console.log('b');
		// },false)
		// 
		//解除上面的事件 
		//div.removeEventListener('click',处理函数,false);
		
		// 绑定事件第三个方法 IE独有 一个事件同样可以绑定多个处理程序
		//div.attachEvent("on"+事件类型，处理函数)
		// div.attachEvent('onclick' , function(){
		// 		console.log('b');
		// 		console.log(this);//这个this指向window
		// } )
		//div.attachEvent('onclick' , function(){
		// 		console.log('c');
		// } )
		//解除上面的事件 div.detachEvent('onclick',处理函数)；

		// 解决第三方法的this指向问题
		// div.attachEvent('onclick' , function(){
		// 		text.call(div);
		// } )
		// function text(){
		// 	console.log('a');
		// }
		

		//封装兼容性的 addEvent()
		// function addEvent(elem,type,handle){
		// 	if(elem.addEventListener){
		// 		elem.addEventListener(type,handle,false);
		// 	}else if(elem.attachEvent){
		// 		elem.attachEvent("on"+type,function(){
		// 			handle.call(elem);
		// 		})
		// 	}else{
		// 		elem['on' +type] = handle;
		// 	}
		// }	
	</script> -->

	<!-- 事件处理模型  一个对象的一个事件类型上的一个处理函数只能实现一种事件处理模型-->
	<!--  事件冒泡 -->
	<!-- focus，blur，change，submit，reset，select 等事件不冒泡 -->
	<!-- 结构上（非视觉上）嵌套关系的元素，会存在事件冒泡的功能，即同一事件，自子元素冒泡向父元素。（自底向上） -->
	<!-- <div class="wrapper" style = "width:300px;height:300px;background-color: red">
		<div class="content" style = "width:200px;height:200px;background-color: green">
			<div class="box" style = "width:100px;height:100px;background-color: yellow"></div>
		</div>
	</div>
	<script>
		var wrapper = document.getElementsByClassName('wrapper')[0];
		var content = document.getElementsByClassName('content')[0];
		var box = document.getElementsByClassName('box')[0];
		
		wrapper.addEventListener('click',function(){
			console.log('wrapper');
		},false)
		content.addEventListener('click',function(){
			console.log('content');
		},false)
		box.addEventListener('click',function(){
			console.log('box');
		},false)
	</script> -->

	<!--事件捕获 只有谷歌浏览器实现了 -->
	<!-- 结构上（非视觉上）嵌套关系的元素，会存在事件捕获的功能，即同一事件，自父元素捕获至子元素（事件源元素）。（自顶向下） -->
	<!-- <div class="wrapper" style = "width:300px;height:300px;background-color: red">
		<div class="content" style = "width:200px;height:200px;background-color: green">
			<div class="box" style = "width:100px;height:100px;background-color: yellow"></div>
		</div>
	</div>
	<script>
		var wrapper = document.getElementsByClassName('wrapper')[0];
		var content = document.getElementsByClassName('content')[0];
		var box = document.getElementsByClassName('box')[0];
		
		wrapper.addEventListener('click',function(){
			console.log('wrapper');
		},true)//看清楚这里是true 不在是原来的 false
		content.addEventListener('click',function(){
			console.log('content');
		},true)
		box.addEventListener('click',function(){
			console.log('box');
		},true)
	</script> -->

	<!-- 一个对象的一个事件类型上的多个处理函数先捕获后冒泡 -->
	<!-- <div class="wrapper" style = "width:300px;height:300px;background-color: red">
		<div class="content" style = "width:200px;height:200px;background-color: green">
			<div class="box" style = "width:100px;height:100px;background-color: yellow"></div>
		</div>
	</div>
	<script>
		var wrapper = document.getElementsByClassName('wrapper')[0];
		var content = document.getElementsByClassName('content')[0];
		var box = document.getElementsByClassName('box')[0];

		wrapper.addEventListener('click',function(){
			console.log('wrapper冒泡');
		},false)
		content.addEventListener('click',function(){
			console.log('content冒泡');
		},false)
		box.addEventListener('click',function(){
			console.log('box冒泡');
		},false)
		wrapper.addEventListener('click',function(){
			console.log('wrapper捕获');
		},true)
		content.addEventListener('click',function(){
			console.log('content捕获');
		},true)
		box.addEventListener('click',function(){
			console.log('box捕获');
		},true)		
	</script> -->

	<!-- 取消冒泡事件 -->
	<!-- <div style = "width:100px;height:100px;background-color: red"></div>
	<script>
		var div = document.getElementsByTagName('div')[0];

		// document.onclick = function(){
		// 	console.log('我冒泡出来了！')
		// }
		// div.onclick = function(e){
		// 	e.stopPropagation();//取消冒泡
		// 	//e是事件对象 ie9以下版本不支持
		// 	console.log('a');
		// }
		
		// div.onclick = function(e){
		// 	e.cancelBubble = true;//取消冒泡 ie9一下用这个
		// 	console.log('b');
		// }
		// 
		// 封装取消冒泡的兼容性函数 stopBubble(event)
		// function stopBubble(event){
		// 	if(event.stopPropagation){
		// 		event.stopPropagation
		// 	}else{
		// 		event.cancelBubble = true;
		// 	}
		// }		
	</script> -->

	<!-- 取消默认事件 例如： 表单提交，a标签跳转，右键菜单等-->
	<!-- <script>
		//oncontextmenu 右键出菜单事件
		// document.oncontextmenu = function(){
		// 	console.log('a');
		// 	return false;//取消默认事件的第一种方法 只有句柄式的事件才好用
		// }
		// 
		// document.oncontextmenu = function(event){
		// 	event.preventDefault();//取消默认事件的第二种方法 W3C标准，IE9以下不兼容
		// }
		// 
		// document.oncontextmenu = function(event){
		// 	event.returnValue = false;//取消默认事件的第三种方法兼容IE
		// 	console.log('a');
		// }
		// 
		// 封装阻止默认事件的函数 cancelHandler(event);
		// function cancelHandler(event){
		// 	if(event.preventDefault){
		// 		event.preventDefault();
		// 	}else{
		// 		event.returnValue = false;
		// 	}
		// }
		// 
		// 小技巧 取消a标签的默认事件
		// <a href="javascript:void(false)"></a>
		// void()里面写什么就相当于 return 什么
	</script> -->

	 <!-- 事件源对象  到底谁触发的它事件-->
	 <!-- <div class = "wrapper" style = "width:100px ; height:100px ;background-color: red">
	 	 <div class = "box" style = "width:50px ; height:50px ;background-color: green"></div>
	 </div>
	 <ul>
	 	<li>1</li>
	 	<li>2</li>
	 	<li>3</li>
	 	<li>4</li>
	 	<li>5</li>
	 	<li>6</li>
	 	<li>7</li>
	 	<li>8</li>
	 	<li>9</li>
	 	<li>10</li>
	 </ul>
	 <script>
	 	// var wrapper = document.getElementsByClassName('wrapper')[0];
	 	// var box = document.getElementsByClassName('box')[0];
	 	// // wrapper.onclick = function(e){
	 	// // 	// console.log(e);//e是事件对象 IE用这个window.event
	 	// // 	// 兼容写法如下
	 	// // 	var event = e || window.event;
	 	// // 	console.log(event);
	 	// // }
	 	// //获取事件源对象
	 	// wrapper.onclick = function(e){
	 	// 	var event = e || window.event;
	 	// 	//火狐有这个event.target ie有这个event.srcElement
	 	// 	//兼容性的写法如下
	 	// 	var target = event.target || event.srcElement; 
	 	// 	console.log(target); 
	 	// }

	 	// 获取事件源对象的用处 例如 点击那个显示那个的内容
	 	//称为事件委托
	 	var ul = document.getElementsByTagName('ul')[0];
	 	ul.onclick = function(e){
	 		var event = e || window.event;
	 		var target = event.target || event.srcElement;
	 		console.log(target.innerText);
	 	}

	 </script> -->
	
	<!-- 事件 小例子 -->
	<!-- <div style = "width:100px;height:100px;background-color: red;position: absolute;left:0;top:0"></div>
	<script>
		var div = document.getElementsByTagName('div')[0];
		var disX,
			disY;
		div.onmousedown = function(e){
			disX = e.pageX - parseInt(div.style.left);
			disY = e.pageY - parseInt(div.style.top);
			document.onmousemove = function(e){
				var event = e || window.event;
				console.log(event.pageX + " " +event.pageY);
				div.style.left = event.pageX - disX +'px';
				div.style.top = event.pageY - disY +'px';
			}
			
			document.onmouseup = function(){
				div.onmousemove = null;
			}

		}
	</script> -->

	<!-- 鼠标事件 -->
	<!-- onclick	当用户点击某个对象时调用的事件句柄。	
	oncontextmenu	在用户点击鼠标右键打开上下文菜单时触发	 
	ondblclick		当用户双击某个对象时调用的事件句柄。	
	onmousedown		鼠标按钮被按下。 down 向下
	onmouseup		鼠标按键被松开。	up 向上
	onmouseenter	当鼠标指针移动到元素上时触发。	enter进入 不支持冒泡
	onmouseleave	当鼠标指针移出元素时触发	leave离开 不支持冒泡
	onmouseover		鼠标移到某元素之上。	over越过
	onmouseout		鼠标从某元素移开。	    out 局外    
	onmousemove		鼠标被移动。	          move移动       --> 
	
	<!-- 区分鼠标的左右键 -->
	<!-- <script>
		// document.onmousedown = function(e){
		// 	if(e.button == 0 ){
		// 		console.log('左键被点击');
		// 	}else if(e.button == 2){
		// 		console.log('右键被点击');
		// 	}else{//e.button == 1
		// 		console.log('滚动轮');
		// 	}
		// }

		// document.onmouseup = function(e){
		// 	if(e.button == 0 ){
		// 		console.log('左键被点击');
		// 	}else if(e.button == 2){
		// 		console.log('右键被点击');
		// 	}else{//e.button == 1
		// 		console.log('滚动轮');
		// 	}
		// }
	</script> -->
	<!-- 事件对象 -->
	<!-- e.offsetX
		 e.offsetY 鼠标距离元素左上角的位置
		 e.pageX
		 e.pageY  鼠标距离浏览器左上角的位置
		 e.screenX
		 e.screenY 鼠标距离界面左上角的位置
	 -->
	<!-- 键盘事件 -->
	<!-- onkeydown	某个键盘按键被按下。	
	onkeypress	某个键盘按键被按下并松开。	
	onkeyup		某个键盘按键被松开。
	onkeydown > onkeypress > onkeyup 
	keydown和keypress的区别
	keydown 可以响应任意键盘按键，keypress只可以响应字符类键盘按键
	keypress返回ASCII码，可以转换成相应字符-->
	
	<!-- 文本类操作事件 -->
	<!-- input,focus,blur,change -->
	<!-- <input type="text" value="请输入用户名" >
	<script>
		var input = document.getElementsByTagName('input')[0];
		input.oninput = function(e){
			console.log(this.value);
		}
		// 
		// input.onchange = function(e){
		// 	console.log(this.value);
		// }//比较鼠标聚焦和移除焦点的两个状态文本的内容 有变化触发事件没有不触发

		// input.onfocus = function(e){//聚焦
		//  	if(this.value == '请输入用户名'){
		//  		this.value = "";
		//  	}
		//  }
		//  input.onblur = function(e){//失去焦点
		//  	if(this.value == ''){
		//  		this.value = "请输入用户名";
		//  	}
		//  }
	</script>
 -->

 		<!-- <script>
		var div = document.getElementsByTagName('div')[0];
		div.addEventListener('click',onDocumentClick,false);
		div.addEventListener('dblclick', onDocumenDblClick,false)
		var clickTimeId;
		function onDocumentClick(event) {  
			clearTimeout(clickTimeId);			 
	        clickTimeId = setTimeout(function() {    
	          	console.log("鼠标单击");
	        }, 250);
      	}
      	function onDocumenDblClick(event) {
        	clearTimeout(clickTimeId);
        	console.log("鼠标双击");
      	}
	</script> -->
	
	<!-- 窗体操作类(window上的事件) -->
	<!-- <script>
		// window.onscroll = function(){//滚动条滚动就触发
		// 	console.log("eee");
		// }
		// 
		// window.onload = function(){//整个页面全部加载完毕就执行
		// 	console.log("eee");
		// }
		// window.onresize = function(){
		// 	console.log('浏览器窗口大小变化就触发');
		// }
	</script> -->

	<!-- json 也叫对象  这个对象的属性名必须加双引号-->
	<!-- <script>
		var obj = {
			name : 'zhang',
			age : 23
		}
		var str = JSON.stringify(obj);//将对象变为字符串
		console.log(str);
		JSON.parse(str);//将上面的字符串转换过来 变成对象

		// 将非标准JSON字符串 转化为标准JSON字符串
		var str = "{name : 14 , age : 22}";
		var JSONstr = eval("("+str+")");
		console.log(JSONstr);
	</script> -->
	
	<!-- DOW树的生成完毕 指的是 DOW节点的解析完毕 并不是DOW节点的加载完毕
	然后会生成CSStree 
	最后两个结合生成 randerTree 渲染树
	当改变DOM节点时会导致 DOM树的 重排(reflow) 严重影响效率
	repaint 重绘   影响效率但是可以接受 -->

	<!-- 一般都是同步加载JS（阻塞html和css的加载） 但是对于一些处理数据 不需要修改DOM的JS可以进行异步加载  -->
	<!-- 异步加载JS 的三种方法 -->
	<!-- 方法一 在引入JS代码的后面加defer 只有IE可以用 但要等到dom文档全部解析完才会被执行 可以把js写在script 标签里-->
	<!-- <script type = "text/javascript" src = "xxx.js" defer></script> -->
	<!-- 方法二 在引入JS代码的后面加async W3C标准方法 自己加载完就执行，async只能加载外部脚本，不能把js写在script 标签里。
-->
	<!-- <script type = "text/javascript" src = "xxx.js" async ></script> -->
	<!-- 方法三 最常用的-->
	<!-- <script>
		var scri = document.createElement('script');
		scri.type = "text/javascript";
		scri.src = "异步加载JS.js";//此时会异步的加载这个.js文件 但不执行
		// scri.onload = function(){
		// 	test();
		// }//提示加载完毕  但是就IE没有  IE 用下面这个
		
		// scri.onreadystatechange = function(){
		// 	if(scri.readyState == "complete" || scri.readyState == "loaded"){//readyState为状态码 初始值为loading
		// 		alert("我加载完毕了！");
		// 	}
		// }//IE独有
		// 
		// 兼容一下上面的两个方法
		if(scri.readyState){
			scri.onreadystatechange = function(){
				if(scri.readyState == "complete" || scri.readyState == "loaded"){
					test();
				}
			}
		}else{
			scri.onload = function(){
				test();
			}
		}
		document.head.appendChild(scri);//这时会执行

	</script> -->
	
	<!-- 用函数封装一下异步加载的第三种方法 -->
	<!-- <script>
		function loadScript(url,callback){//callback回调函数的意思
			var scri = document.createElement('script');		
			if(scri.readyState){
				scri.onreadystatechange = function(){
					if(scri.readyState == "complete" || scri.readyState == "loaded"){
						callback();
					}
				}
			}else{
				scri.onload = function(){
					callback();
				}
			}
			scri.src = url;//先绑定事件 在下载文件
			document.head.appendChild(scri);
		}
		loadScript('异步加载JS.js',function(){
			test();
		})//这样调用上面的方法
	</script> -->
	
	<!-- js加载时间线 -->
	<!-- 1、创建Document对象，开始解析web页面。解析HTML元素和他们的文本内容后添加Element对象和Text节点到文档中。这个阶段document.readyState = 'loading'。
	
	2、遇到link外部css，创建线程加载，并继续异步解析文档。
	
	3、遇到script外部js，并且没有设置async、defer，浏览器加载，并阻塞，等待js加载完成并执行该脚本，然后继续解析文档。
	
	4、遇到script外部js，并且设置有async、defer，浏览器创建线程加载，并继续解析文档。
	对于async属性的脚本，脚本加载完成后立即执行。（异步禁止使用document.write()）
	
	5、遇到img等，先正常解析dom结构，然后浏览器异步加载src，并继续解析文档。
	
	6、当文档解析完成，document.readyState = 'interactive'。
	
	7、文档解析完成后，所有设置有defer的脚本会按照顺序执行。（注意与async的不同,但同样禁止使用document.write()）;
	
	8、document对象触发DOMContentLoaded事件，这也标志着程序执行从同步脚本执行阶段，转化为事件驱动阶段。
	
	9、当所有async的脚本加载完成并执行后、img等加载完成后，document.readyState = 'complete'，window对象触发load事件。

	代码见44号笔记 -->

	<!-- Math对象 -->
	<!-- Math对象
		PI 返回圆周率
		ceil() 向上取整 
		floor() 向下取整
		round() 四舍五入
		abs()   绝对值
		random() 返回0-1之间的随机数 -->
	<!-- <script>
		//该表URL #/login 会打印出来
		// window.addEventListener('hashchange',function(){
		// 	console.log(location.hash)
		// })
	</script> -->
</body>
</html>