<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>ES6继续探</title>
</head>
<body>
	<script>
		/*
			原来创建类的方法
		 	function Student(name ,age){
		 		this.name = name;
		 		this.age = age
		 	}
		 	var stu = new Student('zx',11);
		 	stu.prototype.ready = function(){}
		 */
		
		/*
		 新创建类的方法  function有遍历提升  但是 ES6中的class没有变量提升
			class Student{
				constructor(name){
					//类本身的函数
					//this指向当前实例
					this.name = name;
					//如果return 一个基本数据类型对这个实例没有影响 如果是引用数据类型将会对这个实例产生影响
				}
			}
			var stu = new Student('zx');
			//Student();//不可以作为不同函数执行  必须new 执行
			console.log(typeof Student);   //function
		 		
		*/
		
		/*
		name的问题（类名的问题）
			let A = class AA{
				//也可以不写这个AA  那么类的名字就是A
				//AA只能在类里面使用 不能在外面用 但是类的名字还是 AA
				constructor(){
					console.log(A.name);		//AA
				}	
				fn(){
					console.log(A.name);		//AA
				}
			}
			//new AA();//这样会报错  这个AA只能在class 里面使用
			let a = new A();
			a.fn();

		*/
			
		/*
			class表达式让类直接执行
		 
			let stu = new class{
				constructor(name){
					console.log(name);
					this.name = name;
				}
			}('zx');
		*/
	
		/*
				类相当于原型，原型上的方法不可以枚举，写在原型上的方法都会被实例继承，假如要给当前类本身加一些方法，
				我们可以在方法得前面加一个关键字 static ,不会被实例继承(但是可以被子类继承 下面有详解)，只有类本身可以使用
				添加static的方法是静态方法 添加static的属性是静态属性 
				静态属性只能在静态方法中使用 静态方法中也只能使用静态属性
				例如Array.of() 只有类本身可以使用 但是 new Array（） 的实例不能使用
				
				class Student{
					constructor(name,age){
						this.name = name;
						this.age = age;
					}
					eat(){
						console.log('这吃饭');
					}
					static look(){
						console.log('我是这个类独有方法');
					}
				}
				let stu = new Student('name');
				stu.eat();
				//stu.look();	//报错 类的实例访问不到 类自己的方法 static
				Student.look();	//只能由这个类来访问
		*/
	
		/*
			原型上的方法不可以枚举
		 
				原来这种创建对象的方法  原型上的方法和属性都可以枚举
				function Student(name){
					this.name = name;
				}
				Student.prototype.eat = function(){
					console.log('我是原型上的方法');
				}
				var stu = new Student('zx');
				stu.eat();
				for(var key in stu){
					console.log(stu[key]);	
				}

				现在这种方法 原型上的方法不可以枚举
				class Student{
					constructor(name){
						this.name = name;
					}
						eat(){}
					}
				let stu = new Student('zx');
				for(let key in stu){
					console.log(key);
				}
		 */
			


		/*
			可以被子类继承
			  
					class Father{
				 		constructor(name){
				 			this.name = name;
				 		}
				 		eat(){
				 			console.log(this.name+'父类可以吃饭');
				 		}
				 		static look(){
				 			console.log('父类的静态方法，他的实例没办法调用');
				 		}
				 	};
				 	class Son extends Father{
				 			// 如果要写constructor 那么必须写 super() 
				 			// 如果不写constructor 系统默认会给加上
				 			// 子类没有this this继承自父类 
				 			// super()执行完之后 子类才会有this
			 			constructor(name){
			 				super(name);	//super 就是父类的 constructor 
			 			}
			 			constructor(..args){
							super(...args); //如果有多个参数
			 			}
				 		eat(){
				 			//当前 super  指向 当前父类的原型
				 			super.eat();
				 		}
				 		static sonLook(){
				 			//当前 super  指向 父类本身
				 			super.look();
				 		}
				 		
				 	}
				 	Son.look();	//子类可以直接调用
				 	// Son.sonLook(); //子类也可以通过 super对象 调用
				 	let son = new Son('zx');
				 	son.eat();
		*/
	
		/*
			Promise 是异步编程的一种解决方案
			Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）;
			一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。
			从pending变为fulfilled   方法 resolve();
			pending变为rejected    方法reject();
			let pro = new promise((resolve,reject)=>{});
			默认有一个参数 这个参数是一个函数 这个函数有两个参数 这两个参数是函数

		
	// 执行顺序 先执行new Promise中的函数=》再执行同步队列中的代码=》then中的回调函数
	// 如果new Promise中的函数有错误会先执行同步队列中的代码=》在执行then中的第二个回调
			let pro = new Promise((resolve,reject)=>{
				//resolve和reject只能执行一个 要么成功 要么失败
				//先写的谁就先执行谁
				console.log(1);//第一个执行  先执行new Promise中的函数
				resolve('success');	
				reject('error');
			})
			pro.then((res)=>{
				//成功的执行了  后面的 失败就不执行了
				console.log(res);	//最后一个执行 then中的回调函数
			},(rej)=>{	//失败执行这个
				console.log(rej);
			})
			console.log(2);//第二个执行 再执行同步队列中的代码
		*/

		/*
		Promise 案例异步加载图片
		 	
			 function LoadImg(url){
			 	return new Promise((resolve,reject)=>{
			 		let img = new Image();
			 		img.src = url;
			 		img.onload = function(){
			 			resolve(img);
			 		};
			 		img.onerror = function(e){
			 			reject(e);
			 		}
			 		
			 	})
			 }

			 LoadImg("http://img.zcool.cn/community/01d881579dc3620000018c1b430c4b.JPG@3000w_1l_2o_100sh.jpg")
			 .then((img)=>{
			 		document.body.appendChild(img);
			 	},(e)=>{
			 		console.log(e);
			 	});
				 
			//  配合jQuery使用
			Promise.all([
				$.ajax({url:'地址',dataType:"数据类型"}),
				$.ajax({url:'地址',dataType:"数据类型"}),
				$.ajax({url:'地址',dataType:"数据类型"})
			]).then(success=>{
				let [a,b,c] = success;
				console.log('成功的回调')
			},err=>{
				console.log('失败的回调')
			})
		*/
		
		/*
		catch 方法
				
				let pro = new Promise((resolve,reject)=>{
					
					resolve('success');
					reject('error');
				});
				//一般情况下都这样
				// pro.then((a)=>{
				// 	console.log(a);
				// },(b)=>{
				// 	console.log(b);
				// })
				// 
				//  现在可以这样
				pro.then((a)=>{
					let a = 1;
					let a = 1;
					console.log(a);
				}).catch((e)=>{
					//catch 捕获错误 new promise中的错误和 then中的错误都可以捕获
					console.log(e)
				});
		 */

		 /*
		 Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。
		 多个 Promise 实例 不能有错 一旦一个有错 就只会执行那一个错误的

		 Promise.race只要有一个实例的状态改变 当前实例的状态就跟着变 
		
				 let p1 = new Promise((resolve,reject)=>{
				 	resolve('p1');
				 })
				 let p2 = new Promise((resolve,reject)=>{
				 	resolve('p2');
				 })
				 let p3 = new Promise((resolve,reject)=>{
				 	resolve('p3');
				 })

				let pAll = Promise.all([p1,p2,p3]);
				pAll.then((s)=>{
					console.log(s);
				}).catch((e)=>{
					console.log(e);
				})
				// Promise.race只要有一个实例的状态改变 当前实例的状态就跟着变
				let pRace = Promise.race([p1,p2,p3]);
				pRace.then((s)=>{
					console.log(s);
				}).catch((e)=>{
					console.log(e);
				})
		*/
	
		/*
			async函数  默认返回一个Promise 对象
		
				 async function eat(){
				 	// return 出来的内容就是成功回调的参数
				 	// 这里有错误就会被 catch 捕获到
				 	throw  new Error("错误");
				 	return '成功';
				 }

				 eat().then((res)=>{
				 	console.log(res);
				 }).catch((e)=>{
				 	console.log(e);
				 })
		 */
		
		/*
			await
		 
		 	let p = new Promise((resolve,reject)=>{
		 			resolve("成功");
		 	})
		 	 async function eat(){
		 	 	//  后面默认是一个Promise实例 如果不是也会默认转为Promise
		 	 	// 直接让Promise 实例的回调执行 返回执行时的参数
				 	let a = await p;
				 //等到await后面异步完成后  才会执行后面的代码
				 	console.log(a);
				 }

				 eat().then((res)=>{
				 	console.log(res);
				 }).catch((e)=>{
				 	console.log(e);
				 })

		*/
	
		/*async function(){
			let data1 = await $.ajax({url:'请求的地址'})
			let data2 = await $.ajax({url:'请求的地址'})
			console.log(data1,data2)
		}*/

	</script>
</body>
</html>