<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>ES6再探</title>
</head>
<body>
	<script>
		/*
		 Symbol
				Symbol是一个新的基本数据类型  而且是一个值类型
				使用Symbol函数执行得到一个Symbol数据类型
				Symbol跟字符串差不多 但是使用Symbol函数得到的每一个数据都是不同的
				Symbol函数可以接受一个参数  是对这个Symbol数据的描述
				即使参数相等 每一个数据也不同
				一般当做对象属性 任意一个Symbol()得到的值都不相同
				Symbol值不能和其他值计算 可以转为布尔值 可以用toString()转字符串

				let sym1 = Symbol();
		 		let sym2 = Symbol();
				console.log(typeof sym1);	//Symbol
				console.log(sym1);			//Symbol()
				console.log(sym2);			//Symbol()
				console.log(sym1 == sym2);	//false
				let obj = {
					name:"zx",
					[sym1]:"zhangxin"
				}
				console.log(obj);
				obj[sym2] = "zhangxin";
				console.log(obj);


		    Symbol.for() //如果之前有相同参数的Symbol值，找到这个值并返回 	如果没有创建一个新的Symbol值
		   		 	let s1 = Symbol.for('foo');
					let s2 = Symbol.for('foo');
					s1 === s2 // true

			Symbol.keyFor(Symbol值) //找到使用Symbol.for()创建的值的描述
							如果是Symbol()创建的是找不出来的  undefined
					let s1 = Symbol.for('foo');
					console.log(Symbol.keyFor(s1)); //foo

		 */
		/*
		   Set    里面没有重复的值   只有value 没有key
		   		它类似于数组，但是成员的值都是唯一的，没有重复的值 默认去重。
				Set 本身是一个构造函数，用来生成 Set 数据结构。 
				Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。
				有 iterable :数组 arguments 元素集合 Set Map 字符串

			size属性  Set实例的个数

			add(value) 	添加某个值，返回增加后的Set实例
						let set = new Set([1,2,3]);
						set.add(10).add(12);
		 				console.log(set); //{1, 2, 3, 10, 12}
			
			clear()  清空所用成员  没有返回值
						let set = new Set([1,5,2,3]);
		 				set.clear();
		 				console.log(set);	//{}

		 	delete(value)  删除某个值，返回一个布尔值，表示删除是否成功。
						let set = new Set([1,5,2,3]);
		 				let success = set.delete(1);
						console.log(success); //true
		 				console.log(set);	//{5, 2, 3}

		 	has(value)	返回一个布尔值，表示该值是否为Set的成员
		 				let set = new Set([1,5,2,3]);
		 				let is = set.has(1);
		 				console.log(is); //true
		 				console.log(set);	//{1, 5, 2, 3}
		 	遍历的方法    
		 	forEach() 	使用回调函数遍历每个成员
		 			let set = new Set([1,5,2,3]);
					set.forEach((value,key) => console.log(value+"   "+key));
					// 1 1
					// 5 5
					// 2 2
					// 3 3	
					Set 结构的键名就是键值（两者是同一个值），因此value与key的值永远都是一样的。  
					forEach方法还可以有第二个参数，表示绑定处理函数内部的this对象。

			keys()：返回键名的遍历器
					let set = new Set(['red', 'green', 'blue']);
					for (let item of set.keys()) {
  						console.log(item);
					}
					// red
					// green
					// blue


			values()：返回键值的遍历器
					let set = new Set(['red', 'green', 'blue']);
					for (let item of set.values()) {
 					 	console.log(item);
					}
					// red
					// green
					// blue				


			entries()：返回键值对的遍历器
					let set = new Set(['red', 'green', 'blue']);
					for (let item of set.entries()) {
					  console.log(item);
					}
					// ["red", "red"]
					// ["green", "green"]
					// ["blue", "blue"]
			应用 数组去重
				let arr = [1,2,1,5,3,9,1,2,5];
				console.log([...new Set(arr)]); 	//[1, 2, 5, 3, 9]

				let arr1 = [1,2,3,4,5];
				let arr2 = [1,2,7,8,9];
				// 并集
				console.log([...new Set([...arr1,...arr2])])
				//交集
				console.log(arr1.filter(item=>arr2.includes(item)));
				//差集 = 并集-交集
				console.log([...new Set([...arr1,...arr2])].filter(item => !arr1.filter(item=>arr2.includes(item)).includes(item)));
		 */
							 
		 /*
		 	Map   key 不重复
		 		一个对象的属性名默认为字符串，如果不是字符串默认转为字符串
		 		Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。
		 		构造函数创建一个Map实例
		 		new Map([[key,value],[key,value],...]);
		 		参数是一个数组 数组的每一项也是一个数组（里面有有两项 key 和value）

		 		size属性  键值对的个数

		 		get(key)	根据key获取value
		 		let obj = {} ,arr = [1,2];
				let map = new Map([[1,'zx'],[true,"zhang"],[obj,{name,"xing"}],[arr,[1,2]]]);
		 				 console.log(map.get(true));	//zhang
		 				 console.log(map.get(obj));		//{name: "xing"}
		 				 console.log(map.get(arr));		//[1, 2]

		 		set(key,value) 设置  如果之前有一样的key会修改原来的value 没有就增加返回map实例
						let map = new Map([[1,'ee'],[true,'zx']]);
						map.set('age',22).set(1,3);
						console.log(map);
						//0: {1 => 3}
						//1: {true => "zx"}
						//2: {"age" => 22}
				
				has(key)  判断key有没有对应的value值 返回布尔
						let map = new Map([[1,'ee'],[true,'zx']]);
						console.log(map.has(1));	//true
				
				delete(key) 删除key对应的value   返回布尔
						let map = new Map([[1,'ee'],[true,'zx']]);
						console.log(map.delete(1));   //true

				clear()  清空所用成员  没有返回值
						let map = new Map([[1,'ee'],[true,'zx']]);
						console.log(map.clear()); //undefined
						console.log(map);     //{}

				遍历的方法
					forEach()   forEach方法还可以接受第二个参数，用来绑定this。
						let map = new Map([[1,'ee'],[true,'zx']]);
						map.forEach((value,key,input)=>{
							console.log(key);	//键
							console.log(value);	//值
							console.log(input); //map实例
						})

					keys()  返回键名的遍历器
						let map = new Map([[1,'ee'],[true,'zx']]);
						for(let key of map.keys()){
								console.log(key);// 1
												 // true
						}

					values()  返回键值的遍历器
						let map = new Map([[1,'ee'],[true,'zx']]);
						for(let value of map.values()){
								console.log(value);  //ee
													 // zx
						}	
					
					entries()  返回键值对的遍历器
						let map = new Map([[1,'ee'],[true,'zx']]);
						for(let [key,value] of map.entries()){
								console.log(key +"  "+ value);	//1  ee
																//true  zx

						}
		  */
		 
		 /*
		 	Proxy  	//对目标对象默认操作的拦截/改写
		 			//new Proxy({拦截的目标target},{拦截下的操作});
		  
				  	let obj = {
				  		name :"zx",
				  		_prop:'foo',			  		
				  	}
				  	//让proxy代理了obj，需要通过proxy去操作代理的obj
				  	var proxy = new Proxy(obj,{
				  			get(target,propKey,receiver){
				  		//get()默认传了三个参数(源对象target,propKey, receiver)
				  				console.log(arguments);
				  				console.log(typeof propKey);   //string
				  				console.log('get拦截 触发了我');
				  				//return什么 获取的就是什么 没有return 就是undefined
				  				return target[propKey];
				  			},
				  			set(target,propkey,value,receiver){
			//set()默认传了四个参数(源对象target,propkey,设置的值value,receiver);
				  				console.log('你需要设置  使用触发了我'); 
				  				target[propkey] = value;	//设置属性名和属性值
				  				return true;	//设置成功了就返回true

				  			},
				  			has(target, key) {
				  				console.log('我会拦截 in ');
				  				if(key[0] === '_'){
				  					//这样就可以隐藏带 _  的属性				  
				  					return false;
				  				}
				  				return key in target;	
				  			}
				  	});
				  	//get 只要是获取 例如：proxy.name  ,就会触发get
					console.log(proxy.name);
					console.log(obj);
					//set 只要是设置 例如：proxy.age = 22  ,就会触发set 返回布尔
					proxy.age = 22;
					console.log(obj);
					//has 判断这个对象有没有某个属性的时候就会触发 返回布尔 例如下面
					console.log("_prop" in proxy);    //false
					console.log("name" in proxy);     //true
					

					var fn = function(){
						return "i am target";
					}
					var p = new Proxy(fn,{
						apply(target, ctx, args){							
							console.log('我拦截了函数执行，返回一个字符串');
							console.log(ctx);	//改变this的
							if(ctx){
								ctx.fn = targte;
								ctx.fn(...args) 
								delete ctx.fn;
							}else{
								target(...args);
							}

							console.log(args);	//函数执行时的实参列表			
							return 'I am the proxy';
						}
					})
					//apply 函数执行就会触发 函数直接执行()  call() apply()
					console.log(p());
					console.log(p(1,2));
					console.log(p.call(obj,1,2));
		*/



	</script>
</body>
</html>