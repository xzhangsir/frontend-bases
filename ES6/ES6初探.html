<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>ES6初探</title>
</head>
<body>
	<script>
		/*
		let : 	1.没有变量提声
				2.在同一个作用域下不可重复声明
				3.不会给window添加属性
		const : 1.没有变量提声
				2.在同一个作用域下不可重复声明
				3.不会给window添加属性	
				4.const定义的是一个常量，一旦声明必须赋值，不可以重新赋值	
		 */

		/*
			{}  一个{}就是一个块级作用域 不能放在行首
			在块级作用域下 var和function声明的变量 可以在外部拿到
						  let 和const声明的变量，只在该块级作用域下有效
						  var  a=[] ;
							for(let i = 0 ; i <10 ;i++){
								a[i] = function(){
								console.log(i);
								}
							}
							a[3]();//3
		 */
		/*
			解构赋值	
				数组	  如果等号右边不是一个数组，默认将其转换为一个类数组
					let arr = [1,2,3,4];
					let [x,y,m,n] = arr;
					console.log(x,y,m,n);//1 2 3 4

					let [x,y,n] = [1,2,3,4,5];
		 			console.log(x,y,n); //1 2 3

					省略赋值
					let [,,y] = [1,2,3,4];
					console.log(y); //3

					不定参数赋值		将后面的值放在一个数组中赋值给y3=[3,4,5,6,7]
					let [y1,y2,...y3] = [1,2,3,4,5,6,7];
					console.log(y1,y2,y3);//1 2 [3,4,5,6,7]

					设置默认值	会先找解构的值 
					只有后面解构的值是undefined的时候这才会用默认值
					let [x,y=10]  = [1,2];
					console.log(x,y);//1 2

					let [x,y=10]  = [1,null];
					console.log(x,y); //1 null

					let [x,y=10]  = [1];
					console.log(x,y); //1 10

					let [x,y=10]  = [1,undefined];
					console.log(x,y); //1 10
				对象 如果等号右边不是一个对象，默认将其转换为一个对象
					let {name:name,age:age} = {name:'zx' , age:20};
					console.log(name,age);//zx 20
					如果变量名和属性名一样  可以简化去掉变量 如下
					let {name,age} = {name:'zx' , age:20};
					console.log(name,age);//zx 20
					默认值
					let {name,age=10} = {name:'zx',age:undefined};
					console.log(name,age);//zx 10

					let {name,age=10} = {name:'zx'};
					console.log(name,age);//zx 10
				对象和数组混用
					let {name:name,age:age,arr:[a1,a2,a3]} = {name:'zx',age:20,arr:["js","jq","vue"]};
					console.log(name,age,a1,a2,a3);

				应用
					function arr([a,b,c]){
						console.log(a,b,c)//1 2 3
					}	
					arr([1,2,3]);
					function getAA({name,age}){
						console.log(name,age); //zx 20
					}
					getAA({name:"zx",age:20});
					function getA({name="zx",age=20}={}){
						console.log(name,age)
					}
					function getB({name,age}={name:"zx",age:20}){
						console.log(name,age)
					}
					getA();//zx 20
					getB();//zx 20
					getA({}); // 相当于{name="zx",age=20}={};//zx 20
					getB({}); // 相当于{name,age} = {};//undefined undefined
		*/		
		
		/*字符串原型上拓展的方法
				1.includes("指定的字符"，【开始查找的位置】);
					判断字符串中有没有指定的字符	返回布尔值 
					第二个参数默认学数字，不是数字传为数字	Number()
					let str = "abcdefg123";
					console.log(str.includes("c"));//true
				2. startsWith endsWith	返回布尔值 
					startsWith 判断字符串是不是以指定字符开头
					stratsWith("指定的字符"，【开始查找的位置】);
					let str = "avd";
					console.log(str.startsWith("a"));//true
					
					endsWith 判断字符串是不是以指定字符结尾
					endsWith("指定的字符"，【从前几个中查找】);
					let str = "avd";
					console.log(str.endsWith("d"));
				3. repeat(num) 将字符串重复num次
					let str = "abc";
					console.log(str.repeat(2));	//abcabc
				4. padStart padEnd
					按照指定字符补全字符串的指定长度
					padStart(指定的长度,"要补得指定字符") //在前面补
					let str = "abx";
					console.log(str.padStart(5,"ace"));//acabx

					padEnd(指定的长度,"要补得指定字符") //在后面补
					let str = "abx";
					console.log(str.padEnd(5,"ace"));//abxac
		*/
		/*
			模板字符串  和普通字符串一样但是他可以添加变量 $(变量)
			let class1 = 'nav' , 
				text1 = '模板字符串';
			document.body.innerHTML += `<p class = "${class1}">${text1}</p>`;
		 */
		/*
			数组 
				Array.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组。
				Array.of() // []
				Array.of(undefined) // [undefined]
				Array.of(1) // [1]
				Array.of(1, 2) // [1, 2]

				Array.from(数组/类数组)  返回一个数组
				console.log(Array.from("1234"));	// ["1", "2", "3", "4"]

				var arr = [12,5,8];
				var res = arr.map(item=>return item * 2)//映射 给你几个返回几个
				console.log(res)//24,10,16

				arr.copyWithin(替换的目标起始位置，查找的起始位置，查找的结束位置)
				会改变原数组
				let arr = [1,2,3,4,5,6,7,8,9];
				console.log(arr.copyWithin(1,5,7)) //[1, 6, 7, 4, 5, 6, 7, 8, 9]

				arr.fill(需要替换的字符，开始的位置，结束的位置);
				会改变原数组
				var arr = [1,2,3,4,5,6,7,8,9];
				console.log(arr.fill("替换",2,4)); //[1, 2, "替换", "替换", 5, 6, 7, 8, 9]
				

				includes(要查找的字符，【开始查找的位置】)
				查找数组中有没有 这个数  返回布尔值
				let arr = [1,2,3,4,5,6];
				console.log(arr.includes(2,2));//true
				

				一下遍历数组的方法 参数是一个函数这个函数的this指向window 如果要改变这个this指向 可以传第二个参数  reduce 和 reduceright不行

				arr.filter 过滤数组 根据返回值去过滤原数组 返回一个新的数组
				let arr = [1,2,3,"字符","12"];
				let arr1 = arr.filter(function(item,index){
					//返回true留下当前项 返回false 过滤掉当前项
					return typeof item === "number";	//1,2,3
				})
				console.log(arr1);


				find 先遍历数组，一旦参数函数返回true就 停止查找返回当前项 只会查找一个
				let arr = [1,2,3,"字符","12"];
		 		let arr1 = arr.find(function(item){
		 			return typeof item === "number";
				 })
		 		console.log(arr1);	//1


		 		findIndex 先遍历数组，一旦参数函数返回true就 停止查找返回当前项的索引 只会查找一个

				let arr = [1,2,3,"字符","12"];
		 		let arr1 = arr.findIndex(function(item){
		 			return typeof item === "number";
				 })
		 		console.log(arr1);	//0


				every 遍历数组 只要返回值有一项为false结果就是false
				let arr = [1,2,4,5,6];
				console.log(arr.every(function(item){
						return typeof item === "number";
				}));			//true

				some 遍历数组 只要返回值有一项为true结果就是true
				let arr = [1,2,4,5,6,"u"];
				console.log(arr.some(function(item){
						return typeof item === "number";
				}));

				reduce 迭代
				reduceright   从右边开始 
				let arr = [1,2,3,4,5];
			 	console.log(arr.reduce(function(prev,item,index){
		 			//prev 上一次的返回值  item当前项
		 			//arr.reduce(function(){},10)   第一个的时候他的上一次返回值为0 第二个参数可以给他传一个第一次的上一项返回值
		 			return prev+item;	//15
		 		}))

			
				keys 遍历每一项索引的接口
				let arr = [1,2,3,4,5];
				for(let index of arr.keys()){
		 			console.log(index);	//0 1 2 3 4
				 }
				for(let item of arr){
		 			console.log(item);	//1 2 3 4 5
				}
				
				entries遍历接口 可以遍历到索引和每一项 每次遍历得到一个新的数组【索引，当前项】
				let arr = [1,2,3,4,5];
				for(let e of arr.entries()){
					console.log(e);
				}
				for(let [index,item] of arr.entries()){
					console.log([index,item]);
				}


			数组空位  	数组的某一索引位置没有值 undefined不是空位
						判断一个数组中的某一个位置是不是空位 用 in
						in：判读数组索引位置上有没有值
						let arr = [,undefined,,,,];
						console.log(arr.length);//5  有几个逗号就有几个空位
						console.log(0 in arr); //false
						console.log(1 in arr); //true
					在ES5中对空位的处理不一致  一般直接跳过空位
					let arr = [1,2,,,,3];
					console.log(arr.filter(function(item){
							console.log(item);
					}))
					在ES6中对空位的处理为undefined
					console.log(arr.find(function(item){
							console.log(item);
					}))

		 */
			/*
				函数
					默认值问题
					function fn(x,y){
					//一般情况下为了防止不传值这样处理 但是传一个值为0，就会有问题
					//这样处理后 我传的 实参就会被修改
						x = x || "我传的是0";
						console.log(x,y);
					}
					fn(0);
					function fn1(x="我传的是0",y){
						//如果给参数传一个默认值 这样我的实参就不会变 
						//如果不传实参 我的默认值 就会有效
						console.log(x,y);
					}
					fn1(0);

					length属性  一般情况下length等于形参的个数
					function fn(x,y){
					}
					console.log(fn.length); //2
					如果给形参添加默认值 length属性就会失真 变成没有默认值形参的个数
					function fn(x,y=2){
					}
					console.log(fn.length); //1


					arguments属性
					function fn(...arg){
						console.log(arguments);//类数组
						console.log(arg);//数组
					}
					fn(1,2,3);

					name属性
					function fn(){}
					console.log(fn.name);//fn
					匿名函数
					console.log((function(){}).name);//空  什么都没有
					特殊情况
					1.通过bind()方法得到一个新的函数  name 是 'bound 原函数的名字'
						 function fn(){};
						 let fn1 = fn.bind('w');
						 console.log(fn1.name);
					2.通过构造函数创建一个函数  name 是 'anonymous'
						正常情况下 ：function(形参){函数体}
						那么通过构造函数创建的呢？
						let fn = new Function("形参","函数体")
						let fn = new Function("函数体")
						eg:
							let fn = new Function("a","return a");
							console.log(fn(1));
							console.log(fn.name);  //anonymous
				参数作用域问题
					函数执行的时候先给形参赋值 形参也是私有变量 如果给形参的默认值是个变量 先看是不是自己的私有变量 不是自己的看全局中是否有这个变量 没有就报错
					let x = 100;
					function fn(x,y=x){
						//私有作用域 ：私有变量 x y
						console.log(x,y);	//1 1
					}
					fn(1);
			 */
			/*
			扩展运算符     ...
				1. 可以将类数组变成数组
					let str = "abc";
					console.log([...str]);  //["a", "b", "c"]
					
					function fn(){
						console.log([...arguments]);  // [1, 2, 3]
					}
					fn(1,2,3);
				2.将数组变成非数组
					let arr1 = [1,2,3];
				 	let arr2 = [5,8,9,40];
				 	console.log([...arr1,...arr2]);//[1,2,3,5,8,9,40]
					求数组的最大值
					 let arr = [1,25,96,85,99,5];
					 console.log(Math.max.call(null,1,25,96,85,99,5));
					 console.log(Math.max.apply(null,arr));
					 console.log(Math.max(...arr));
					 console.log(eval("Math.max("+arr+")"));
			 */
			/*
			箭头函数   箭头函数都是匿名函数
					let fn = (形参)=>{函数体};
					形参只有一个  可以省略（）
					如果函数体只有一行代码return  {}和return  可以省略
					let fn = x=>x+1;
					上面的等同于 let fn = x=>{return x+1};
				eg:
				let arr = ["ee",1,2,5,'ww'];
				let num = arr.filter(item=>typeof item === 'number');
				console.log(num); //[1, 2, 5]
				箭头函数的特点：
				1.箭头函数没有this指向 里面的this是上一级作用域下的this
				// 箭头函数 内部的 this 和 外部的 this  指向一致

				2.箭头函数没有arguments  如果要可以这样
					let fn = (...arg)=>{
						console.log(arg);
					}
					fn(1,2,3);
				3.箭头函数不可以用做 构造函数
			 */
			 /*
			 	对象   一个对象属性名默认为字符串 如果你写的不是字符串默认转为字符串
			 		let name = 'zx',age = 22;
			  		let str = 'sex'
			  		let student = {
			  			name,	//等同于 name:'zx'
			  			age,    //等同于 age:22
			  			fn(){}, //等同于 fn:function(){}
			  		// 如果属性名是字符串  需要这样写
			  			[str]:"男"	//等同于 sex:"男"
			  		}
				Object对象方法的拓展
					console.dir(Object); //打印出这个对象的属性和方法
					
					Object.is(x,y) 判断x和y是否相等
					console.log(Object.is(NaN,NaN)); //true 

					Object.assign(obj1,obj2);//合并对象
					将obj2合并到obj1		并返回obj1 
					let obj1 = {name:'zx'};
				  	let obj2 = {age :22};
				  	Object.assign(obj1,obj2);
				  	console.log(obj1);  //{name: "zx", age: 22}

				ES7中提供了对象的扩展运算符 ...
				  	let obj1 = {name:'zx'};
				  	let obj2 = {age :22};
				  	let school = {...obj1,...obj2};		//合并对象
				  	console.log(school);	//{name: "zx", age: 22}
				
				Object.keys(对象) //返回值 数组【所有可以枚举的属性】
					let obj = {name:'zx',age:22};
			  		console.log(Object.keys(obj));   //["name", "age"]
				
				Object.values(对象)  //返回值 数组【所有可以枚举的属性的键值】
					let obj = {name:'zx',age:22};
			  		console.log(Object.values(obj));  //["zx", 22]

			  	Object.entries(对象)  //返回值 数组【没一项也是一个数组【键，值】】
			  		let obj = {name:'zx',age:22};
			  		console.log(Object.entries(obj));   //[Array(2), Array(2)]

			get 和set
			  	let obj = {
			  		_name:'zx',
			  		get name(){
			  			//只要通过obj获取name这个属性就会触发这个函数
			  			//可以通过return 返回值
			  			console.log(1);
			  			return this._name;
			  		},
			  		set name(val){		//必选传参数
			  			//只要通过obj给name这个属性设置值 就会触发这个函数
			  			console.log(2);
			  			this._name = val;	//设置 name值
			  		}
			  	}
			  	console.log(obj.name);  // zx  会触发上面的get 方法
			  	obj.name = "zhang";
			  	console.log(obj.name);	// zhang
			  */
			  	
			  function *show(){
			  	alert(1);
			  	yield;
			  	alert(2);
			  }
			  let s = show();
			  s.next()
			  s.next()

	</script>

		
</body>
</html>